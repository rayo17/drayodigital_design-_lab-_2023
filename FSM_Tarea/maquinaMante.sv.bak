module maquinaMante(input x, clk, rst, output enable_mant, mux_error, msj);
	
  // Declaración de variables
	logic [1:0] state, next_state;
	logic t;
  //logic [7:0] countClock; 
	
	wire x_mux;
	
	reg [7:0] contClock;
	logic t_aux;

	// Contador de clock
	always_ff @(posedge clk or posedge rst) begin
	 if (rst) begin
		contClock <= 8'b00000000;
	 end 
	 else begin
		contClock <= contClock + 1;

	 end
	end
	  
	// verifica la cantidad de clock 
	always @* begin
		if(contClock < 200) 
		t_aux <= 0;
	else
		t_aux <= 1;
	end


	assign t = t_aux;
	
	// contador de mantenimientos
   Contador_mant Contador_mant(.reset(rst), .clk(clk), .enable_mant(enable_mant), .contMant(x_mux));	
	
	
	//Estado actual
	always_ff @(posedge clk or posedge rst)
		if (rst) begin
			state = 2'b00;
		end
		else begin
			state = next_state;
			
		end

	
  // Lógica para el siguiente estado
  // 00 estado inicial 
  // 01 estado mantenimiento
  // 10 estado compara ciclos
  // 11 estado error
  always_comb
    case(state)

      2'b00: if (x) next_state = 2'b01; else next_state = 2'b10;
      2'b10: if (t==200) next_state = 2'b11; else next_state = 2'b00;
      2'b01: next_state = 2'b00;
      default: next_state = 2'b00;
    endcase

  // Lógica para las salidas
  
  assign enable_mant = (state == 2'b01);
  assign mux_error = (state == 2'b11);
   
  
  Mux Mux(.x(enable_mant), .s(mux_error), .msj(msj));

  
	

endmodule
